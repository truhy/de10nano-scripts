# Altera cyclone V SoC family, 5Cxxx
# Note: Intel/Terasic DE series kits JTAG chain order FPGA, DAP then CPU

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME fpgasoc
}

# Subsidiary TAP: fpga
if { [info exists FPGA_TAPID] } {
    set _FPGA_TAPID $FPGA_TAPID
} else {
    set _FPGA_TAPID 0x02d020dd
}
jtag newtap $_CHIPNAME.fpga tap -irlen 10 -ircapture 0x01 -irmask 0x3 -expected-id $_FPGA_TAPID

# CoreSight Debug Access Port
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x4ba00477
}
jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x01 -irmask 0x0f -expected-id $_DAP_TAPID

# Cortex-A9 target
# Base addresses of cores:
# core 0  -  0x80110000
# core 1  -  0x80112000

# Slow speed to be sure it will work
adapter speed 1000

set _TARGETNAME1 $_CHIPNAME.cpu.0
set _TARGETNAME2 $_CHIPNAME.cpu.1

# A9 core 0
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
target create $_TARGETNAME1 cortex_a -dap $_CHIPNAME.dap \
    -coreid 0 -dbgbase 0x80110000

$_TARGETNAME1 configure -event reset-start { adapter speed 1000 }
$_TARGETNAME1 configure -event reset-assert-post "cycv_dbginit $_TARGETNAME1"

# A9 core 1
#target create $_TARGETNAME2 cortex_a -dap $_CHIPNAME.dap \
#    -coreid 1 -dbgbase 0x80112000

#$_TARGETNAME2 configure -event reset-start { adapter speed 1000 }
#$_TARGETNAME2 configure -event reset-assert-post "cycv_dbginit $_TARGETNAME2"

proc cycv_dbginit {target} {
    # General Cortex-A8/A9 debug initialisation
    $target cortex_a dbginit
}

proc cortex_a9_disable_mmu_and_cache {target} {
    # arm mcr pX op1 CRn CRm op2 value
    echo "Disabling MMU and caches (I+D).."
    catch {
        $target arm mcr 15 0 7 5 0 0
        $target arm mcr 15 0 7 7 0 0
        # Invalidate all TLBs
        $target arm mcr 15 0 8 5 0 0
        $target arm mcr 15 0 8 6 0 0
        $target arm mcr 15 0 8 7 0 0
        $target arm mcr 15 4 8 3 0 0
        $target arm mcr 15 4 8 7 0 0
        set cp [$target arm mrc 15 0 1 0 0]
        echo "SCTRL => [format 0x%x $cp]"
        set mask [expr {1 << 29 | 1 << 12 | 1 << 11 | 1 << 2 | 1 << 1 | 1 << 0}]
        set cp [expr {($cp & ~$mask)}]
        $target arm mcr 15 0 1 0 0 $cp
        echo "SCTRL <= [format 0x%x $cp]"
    }
}

proc cycv_reset {target} {
    # Parameters
    set RESET_CTRL_ADDR "0xffd05004"

    catch {
        # Soft reset all CPU cores using the Cyclone V HPS Reset Manager CTRL memory-mapped register
        echo "cycv_reset: Soft resetting.."
        $target mww phys $RESET_CTRL_ADDR 0x00100002
    }

    # Note: This reset doesn't generate an event so you would need to manually call cortex_a dbginit
    halt
    $target cortex_a dbginit
    $target cortex_a dacrfixup on
    # Use this if you want the stepping to not jump into another interrupt, i.e. interrupts are disabled when stepping
    #$target cortex_a maskisr on
}

proc cycv_spl_init {uboot_file} {
    # Parameters for U-Boot SPL to run from HPS (CPU) OCRAM
    set SPL_ENTRY 0xffff0000

    echo "cycv_spl_init: Loading U-Boot SPL.."
    load_image $uboot_file

    echo "cycv_spl_init: Executing U-Boot SPL at $SPL_ENTRY.."
    resume $SPL_ENTRY
}
